#+TITLE: Emacs configuration file
#+AUTHOR: Carlos Perez
#+EMAIL: carlosperezmolano@gmail.com

#+DESCRIPTION: A literate programming version of my Emacs Initialization script, loaded by the .emacs file.
#+PROPERTY:    header-args:emacs-lisp  :tangle ~/.emacs.d/elisp/init-main.el
#+PROPERTY:    header-args:shell  :tangle no
#+PROPERTY:    header-args        :results silent   :eval no-export   :comments org
#+OPTIONS:     num:nil toc:nil todo:nil tasks:nil tags:nil
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil

* Introduction
This is my Emacs configuration file written in org-mode. You can take a look at
the [[file:./init.el][init file]]
It was inspired by Daniel Mai's config
[[https://github.com/danielmai/.emacs.d][Github repo]]
[[https://www.youtube.com/watch?v=gRb3bq0NiXY&feature=iv&src_vid=VIuOwIBL-ZU&annotation_id=annotation_1954847607][Youtube video]]

I have also adapted the approach from Howard Abrams in [[https://github.com/howardabrams/dot-files/blob/master/emacs.org][github]]

Other useful configs:
 - [[https://gist.github.com/nilsdeppe/7645c096d93b005458d97d6874a91ea9][My Emacs init file · GitHub]]
 - [[https://github.com/a13/emacs.d][GitHub - a13/emacs.d]]
 - [[https://github.com/skeeto/.emacs.d/blob/master/init.el][.emacs.d/init.el at master · skeeto/.emacs.d · GitHub]]
 - [[http://aaronbedra.com/emacs.d/][Aaron Bedra]]
 - [[https://github.com/dakra/dmacs][GitHub - dakra/dmacs: Emacs Literate Configuration with borg]]

To "load" the contents of this file, add the following to =$HOME/.init.el=:

#+BEGIN_SRC elisp :tangle ~/.emacs.d/init.el
;; Load our Literate Programming version of our Dot Emacs
;; file, from file: ~/dot-files/emacs.org
(load-file "~/.emacs.d/elisp/init-main.el")
(server-start)
#+END_SRC

Keep track of loading time
#+BEGIN_SRC emacs-lisp
(defconst emacs-start-time (current-time))
#+END_SRC

* General Settings
This section has been copied from the configuration of Howard Abrams.
** My Directory Location

Normally, the =user-emacs-directory= stores everything in a
=.emacs.d= directory in the home directory, however, Aquamacs
overrides that, and since I now feel the need to use these settings
for both editors (sure feels like XEmacs all over again).

Any way, I have a new global variable for that:

#+BEGIN_SRC emacs-lisp
(defconst my/emacs-directory (concat (getenv "HOME") "/.emacs.d/"))

(defun my/emacs-subdirectory (d) (expand-file-name d my/emacs-directory))
#+END_SRC

** Directory Structure

In case this is the first time running this on a computer, we need
to make sure the following directories have been created.

#+BEGIN_SRC emacs-lisp
(let* ((subdirs '("elisp" "backups"))
       (fulldirs (mapcar (lambda (d) (my/emacs-subdirectory d)) subdirs)))
  (dolist (dir fulldirs)
    (when (not (file-exists-p dir))
      (message "Make directory: %s" dir)
      (make-directory dir))))
#+END_SRC

** Setting up the Load Path

Extra packages not available via the package manager go in my personal stash
at: =$HOME/.emacs.d/elisp=

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (my/emacs-subdirectory "elisp"))
#+END_SRC

** Custom-file
#+BEGIN_SRC emacs-lisp
;; keep customize settings in their own file
(setq custom-file "~/.emacs.d/custom.el")
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** Backups
This is one of the things people usually want to change right away.
By default, Emacs saves backup files in the current directory. These
are the files ending in ~ that are cluttering up your directory
lists. The following code stashes them all in ~/.emacs.d/backups,
where I can find them with C-x C-f (find-file) if I really need to.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC

** Speed-up startup
Speed-up startup, taken from [[https://yiufung.net/post/pure-emacs-lisp-init-skeleton/][Pure Emacs-Lisp Init Skeleton]] 
#+BEGIN_SRC emacs-lisp
;; Speed up startup
(setq gc-cons-threshold 402653184
      gc-cons-percentage 0.6)
(add-hook 'after-init-hook
          `(lambda ()
             (setq gc-cons-threshold 800000
                   gc-cons-percentage 0.1)
             (garbage-collect)) t)
#+END_SRC

* Package initialization
** Package manager
Emacs has become like every other operating system and has a package manager,
but we need to add more to get all the functionality.
#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'load-path "~/.emacs.d/packages/lisp")

(setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                         ("gnu"       . "http://elpa.gnu.org/packages/")
                         ("melpa"     . "http://melpa.org/packages/")
                         ("melpa-stable" . "http://stable.melpa.org/packages/")))
 
(package-initialize)
(package-refresh-contents)
#+END_SRC

Set priorities of packages. Higher values are searched first
#+BEGIN_SRC emacs-lisp
(setq package-archive-priorities
      '(("melpa-stable" . 200)
        ("melpa"        . 100)
        ("org"          . 110)
        ("gnu"         .  150)))
#+END_SRC

** Use-package
Remeber to always use ~:ensure nil~ for internal packages, as described here
[[https://github.com/jwiegley/use-package/issues/243][don't fail on using internal packages with use-package-always-ensure]]

#+BEGIN_SRC emacs-lisp
(setq-default use-package-always-ensure t ; Auto-download package if not exists
              ;; use-package-always-defer t ; Always defer load package to speed up startup
              use-package-verbose nil ; Don't report loading details
              use-package-expand-minimally t  ; make the expanded code as minimal as possible
              use-package-enable-imenu-support t) ; Let imenu finds use-package definitions

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

;; to further reduce load-time
(eval-when-compile
  (require 'use-package))
#+END_SRC

Now, extend its functionality

#+BEGIN_SRC emacs-lisp
(use-package system-packages
  :custom
  (system-packages-noconfirm t))

(use-package use-package-ensure-system-package)

;; :diminish keyword
(use-package diminish)

;; :bind keyword
(use-package bind-key)

;; so we can (require 'use-package) even in compiled emacs to e.g. read docs
(use-package use-package
  :commands use-package-autoload-keymap)
#+END_SRC

** Time tracking of initialization

#+BEGIN_SRC emacs-lisp
(let ((elapsed (float-time (time-subtract (current-time)
                                          emacs-start-time))))
  (message "Loaded packages in %.3fs" elapsed))
#+END_SRC

** Init file support
Load up a collection of enhancements to Emacs Lisp, including dash, s for
string manipulation, and f for file manipulation.
#+BEGIN_SRC emacs-lisp
(require 'cl)

(use-package dash
  :ensure t
  :config (eval-after-load "dash" '(dash-enable-font-lock)))

(use-package s
  :ensure t)

(use-package f
  :ensure t)

#+END_SRC

* Global defaults
Begin initialization
#+BEGIN_SRC emacs-lisp
(use-package emacs
  :init
  (put 'narrow-to-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  :config
  (fset 'yes-or-no-p 'y-or-n-p)
  :custom
  (scroll-step 1)
  (inhibit-startup-screen t "Don't show splash screen")
  (use-dialog-box nil "Disable dialog boxes")
  (x-gtk-use-system-tooltips nil)
  (enable-recursive-minibuffers t "Allow minibuffer commands in the minibuffer")
  (indent-tabs-mode nil "Spaces!")
  (debug-on-quit nil)
  (locale-coding-system 'utf-8)
  )
#+END_SRC

Encoding system
   #+BEGIN_SRC emacs-lisp
(use-package mule
  :ensure nil
  :config
  (prefer-coding-system 'utf-8)
  (set-language-environment "UTF-8")
  (set-terminal-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (set-locale-environment "en_US.UTF-8"))
#+END_SRC

Parenthesis
   #+BEGIN_SRC emacs-lisp
(use-package paren
  :ensure nil
  :config (show-paren-mode))
#+END_SRC

* Interface
** GUI
Disable gui elements we don't need:
#+BEGIN_SRC emacs-lisp
(use-package tool-bar
  :ensure nil
  :config
  (tool-bar-mode -1))

(use-package scroll-bar
  :ensure nil
  :config
  (scroll-bar-mode -1))

(use-package menu-bar
  :ensure nil
  :config
  (menu-bar-mode -1)
  :bind
  ([S-f10] . menu-bar-mode))

(use-package tooltip
  :ensure nil
  :custom
  (tooltip-mode -1))
#+END_SRC

Add those we want instead:
#+BEGIN_SRC emacs-lisp
(use-package time
  :defer t
  :custom
  (display-time-default-load-average nil)
  (display-time-24hr-format t)
  :config
  (display-time-mode t))
#+END_SRC

Fancy stuff
   #+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t
  :defer t
  :config
  (setq all-the-icons-mode-icon-alist
        `(,@all-the-icons-mode-icon-alist
          (package-menu-mode all-the-icons-octicon "package" :v-adjust 0.0)
          (jabber-chat-mode all-the-icons-material "chat" :v-adjust 0.0)
          (jabber-roster-mode all-the-icons-material "contacts" :v-adjust 0.0)
          (telega-chat-mode all-the-icons-fileicon "telegram" :v-adjust 0.0
                            :face all-the-icons-blue-alt)
          (telega-root-mode all-the-icons-material "contacts" :v-adjust 0.0))))

(use-package all-the-icons-dired
  :ensure t
  :hook
  (dired-mode . all-the-icons-dired-mode))

(use-package all-the-icons-ivy
  :ensure t
  :after ivy
  :custom
  (all-the-icons-ivy-buffer-commands '() "Don't use for buffers.")
  :config
  (all-the-icons-ivy-setup))

(use-package doom-modeline
  :ensure t
  :hook
  (after-init . doom-modeline-init)
  :custom
  (doom-modeline-major-mode-icon t)
  (doom-modeline-buffer-file-name-style 'buffer-name)
  (doom-modeline-icon t))
#+END_SRC

And the winner is…
#+BEGIN_SRC emacs-lisp
(use-package winner
  :config
  (winner-mode 1))
#+END_SRC

* Function definitions
** Terminal or GUI

#+BEGIN_SRC emacs-lisp

(defun is-in-terminal()
  "Returns true if emacs is running in a terminal"
    (not (display-graphic-p)))

(defmacro when-term (&rest body)
  "Works just like `progn' but will only evaluate expressions
   in VAR when Emacs is running in a terminal else just nil."
  `(when (is-in-terminal) ,@body))

(defmacro when-not-term (&rest body)
  "Works just like `progn' but will only evaluate expressions
   in VAR when Emacs is running in a terminal else just nil."
  `(when (not (is-in-terminal)) ,@body))
#+END_SRC

** Tangle automatically 

#+BEGIN_SRC emacs-lisp
(defun my/tangle-dotfiles ()
  "If the current file is in '~/dot-files', the code blocks are tangled"
  (when (equal (expand-file-name (file-name-directory (directory-file-name buffer-file-name)))
               (expand-file-name (concat (getenv "HOME") "/dot-files/")))
    (org-babel-tangle)
    (message "%s tangled" buffer-file-name)))

(add-hook 'after-save-hook #'my/tangle-dotfiles)
#+END_SRC

** Disable all themes
#+BEGIN_SRC emacs-lisp
(defun cp/disable-all-themes ()
  (interactive)
  (mapc #'disable-theme custom-enabled-themes))
#+END_SRC

* Theme
All this configuration is taken from [[https://www.greghendershott.com/2017/02/emacs-themes.html][Emacs Themes]]
Use ~counsel-load-theme~ to change between them.
** Advice and hooks
#+BEGIN_SRC emacs-lisp
;;; Theme hooks

(defvar cp/theme-hooks nil
  "((theme-id . function) ...)")

(defun cp/add-theme-hook (theme-id hook-func)
  (add-to-list 'cp/theme-hooks (cons theme-id hook-func)))

(defun cp/load-theme-advice (f theme-id &optional no-confirm no-enable &rest args)
  "Enhances `load-theme' in two ways:
1. Disables enabled themes for a clean slate.
2. Calls functions registered using `cp/add-theme-hook'."
  (unless no-enable
    (cp/disable-all-themes))
  (prog1
      (apply f theme-id no-confirm no-enable args)
    (unless no-enable
      (pcase (assq theme-id cp/theme-hooks)
        (`(,_ . ,f) (funcall f))))))

(advice-add 'load-theme
            :around
            #'cp/load-theme-advice)

#+END_SRC

** Leuven-theme
#+BEGIN_SRC emacs-lisp
(use-package leuven-theme
  :ensure t
  :defer t)
#+END_SRC

** Material theme
#+BEGIN_SRC emacs-lisp
(use-package material-theme
  :ensure t
  :defer t
  :init
  ;; (defun cp/material-theme-hook ()
  ;;   (loop for n from 1 to 8
  ;;         do (set-face-attribute (intern-soft (format "org-level-%s" n))
  ;;                                nil
  ;;                                :height     'unspecified
  ;;                                :background 'unspecified
  ;;                                :box        'unspecified)))
  ;; (cp/add-theme-hook 'material       #'cp/material-theme-hook)
  ;; (cp/add-theme-hook 'material-light #'cp/material-theme-hook)
)
#+END_SRC

** Solarized theme
Here's some configuration for [[https://github.com/bbatsov/solarized-emacs/][bbatsov's solarized themes]].

#+begin_src emacs-lisp
  (use-package solarized-theme
    :ensure t
    :defer t
    ;; :after (org)
    :init
    (defun cp/solarized-theme-hook ()
      ;; (require 'color)
      ;; (set-face-attribute 'org-block nil :background
      ;;                     (color-darken-name
      ;;                      (face-attribute 'default :background) 5))
      ;; (set-face-attribute 'font-lock-constant-face nil :weight 'normal)
      ;; (set-face-attribute 'font-lock-function-name-face nil :weight 'bold))
      )

    ;; (cp/add-theme-hook 'solarized-dark  #'cp/solarized-theme-hook)
    ;; (cp/add-theme-hook 'solarized-light #'cp/solarized-theme-hook)
    :config
    (setq solarized-use-variable-pitch nil
          solarized-use-less-bold t
          solarized-use-more-italic nil
          solarized-distinct-doc-face t
          solarized-high-contrast-mode-line t
          ;; I find different font sizes irritating.
          solarized-height-minus-1 1.0
          solarized-height-plus-1 1.0
          solarized-height-plus-2 1.0
          solarized-height-plus-3 1.0
          solarized-height-plus-4 1.0)    
    )

#+end_src

** Smart mode line 
   [[https://github.com/Malabarba/smart-mode-line][Github page]]
#+begin_src emacs-lisp              
;;(setq sml/theme 'light)
;;(sml/setup)
#+end_src

** Parchment theme
#+BEGIN_SRC emacs-lisp
(use-package parchment-theme
  :ensure t
  :defer t
  )
#+END_SRC

** Use this theme
#+BEGIN_SRC emacs-lisp
(load-theme 'solarized-light t)
#+END_SRC

** Mixed pitch
#+BEGIN_SRC emacs-lisp
(use-package mixed-pitch
  :hook
  ;; If you want it in all text modes:
  (org-mode . mixed-pitch-mode))
#+END_SRC

* Text
** Visual fill column
A small Emacs minor mode that mimics the effect of fill-column in
visual-line-mode. Instead of wrapping lines at the window edge, which is the
standard behaviour of visual-line-mode, it wraps lines at fill-column. If
fill-column is too large for the window, the text is wrapped at the window
edge.

#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :defer t
  :hook visual-line-mode
  )
#+END_SRC

** Line wrapping
#+BEGIN_SRC emacs-lisp
(use-package fill
  :ensure nil
  :commands turn-on-auto-fill
  :bind (("C-c T f" . auto-fill-mode)
         ("C-c T t" . toggle-truncate-lines))
  :custom
  (fill-column 79)
  :init
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
  (add-hook 'prog-mode-hook 'turn-on-auto-fill)
  :diminish auto-fill-mode)
#+END_SRC

** Unfill paragraph
Taken from [[https://www.emacswiki.org/emacs/UnfillParagraph][EmacsWiki: Unfill Paragraph]]

#+BEGIN_SRC emacs-lisp
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and makes it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
        ;; This would override `fill-column' if it's an integer.
        (emacs-lisp-docstring-fill-column t))
    (fill-paragraph nil region)))

;; Handy key definition
(define-key global-map "\M-Q" 'unfill-paragraph)

#+END_SRC

** Visual line

#+BEGIN_SRC emacs-lisp
(use-package text-mode
  :ensure nil
  :hook turn-on-visual-line-mode
)
#+END_SRC

** Smartparens

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :defer 1
  :hook ((
          emacs-lisp-mode lisp-mode hy-mode go-mode cc-mode python-mode
                          typescript-mode javascript-mode java-mode)
         . smartparens-strict-mode)
  :config
  (require 'smartparens-config)
  (smartparens-global-mode 1)
  :custom
  (sp-show-pair-from-inside nil)
  :diminish smartparens-mode)
#+END_SRC

* Writing
** Writegood mode

#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
  :ensure t
  :defer t
  :config
  (global-set-key "\C-cg" 'writegood-mode)
)
#+END_SRC

** Wordcount mode

#+BEGIN_SRC emacs-lisp
(use-package wc-mode
  :ensure t
  :defer t
  :config
  (global-set-key "\C-cw" 'wc-mode)
)
#+END_SRC

** org-wc

#+BEGIN_SRC emacs-lisp
(use-package org-wc
  :ensure t
  :defer t
  :config
)
#+END_SRC

** Writeroom-mode
A minor mode for Emacs that implements a distraction-free writing mode similar
to the famous Writeroom editor for OS X.

#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
  :defer t
  :after visual-fill-column
  )
#+END_SRC

** Spell checking
:PROPERTIES:
:header-args:emacs-lisp:     :tangle no
:END:

*** Flyspell
Spell checking with FlySpell, which uses the built-in settings of Ispell. In
his case, it is configured to use Aspell, which requires you to download it in
your system. 

Some useful commands, taken from [[http://ergoemacs.org/emacs/emacs_spell_check.html][Emacs: Spell Checking]]

Check this for future tweaks: [[https://www.emacswiki.org/emacs/FlySpell][EmacsWiki: Fly Spell]]
 
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :ensure t
  :diminish flyspell-mode
  :init
  (add-hook 'prog-mode-hook 'flyspell-prog-mode)

  ;; (dolist (hook '(text-mode-hook org-mode-hook))
  ;;   (add-hook hook (lambda () (flyspell-mode 0))))

  ;; (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
  ;;   (add-hook hook (lambda () (flyspell-mode -1))))

  :config
  (setq 
   ;; ispell-program-name "c:/msys64/mingw64/bin/aspell.exe"
   ispell-local-dictionary "en_US"
   ;; ispell-dictionary "american" ; better for aspell
   ispell-extra-args '("--sug-mode=ultra" "--lang=en_US")
   ispell-list-command "--list"
   ispell-local-dictionary-alist '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "['‘’]"
                                    t ; Many other characters
                                    ("-d" "en_US") nil utf-8))))
#+END_SRC

*** Flyspell correct

#+BEGIN_SRC emacs-lisp
(use-package flyspell-correct-ivy
  :after ivy
  :bind ("C-M-;" . flyspell-correct-wrapper)
  :init
  (setq flyspell-correct-interface #'flyspell-correct-ivy))
#+END_SRC

* Ivy 
Great explanation from [[https://sam217pa.github.io/2016/09/13/from-helm-to-ivy/][here]]

#+BEGIN_SRC emacs-lisp
(use-package ivy :ensure t
  :diminish (ivy-mode . "")
  :bind
  (:map ivy-mode-map
   ("C-'" . ivy-avy))
  :config
  (ivy-mode 1)
  ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
  (setq ivy-use-virtual-buffers t)
  ;; number of result lines to display
  (setq ivy-height 10)
  ;; does not count candidates
  (setq ivy-count-format "")
  ;; no regexp by default
  (setq ivy-initial-inputs-alist nil)
  ;; configure regexp engine.
  (setq ivy-re-builders-alist
	;; allow input not in order
        '((t   . ivy--regex-ignore-order))))
#+END_SRC

* Swiper

Taken from C'est la Z [[http://cestlaz.github.io/posts/using-emacs-6-swiper/][link]]

#+BEGIN_SRC emacs-lisp
;; it looks like counsel is a requirement for swiper
(use-package counsel
  :ensure t
  )

(use-package swiper
  :ensure try
  :config
  (progn
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (global-set-key "\C-s" 'swiper)
    (global-set-key (kbd "C-c C-r") 'ivy-resume)
    (global-set-key (kbd "<f6>") 'ivy-resume)
    (global-set-key (kbd "M-x") 'counsel-M-x)
    (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    (global-set-key (kbd "<f1> f") 'counsel-describe-function)
    (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
    (global-set-key (kbd "<f1> l") 'counsel-load-library)
    (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
    (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
    (global-set-key (kbd "C-c g") 'counsel-git)
    (global-set-key (kbd "C-c j") 'counsel-git-grep)
    (global-set-key (kbd "C-c k") 'counsel-ag)
    (global-set-key (kbd "C-x l") 'counsel-locate)
    (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
    (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
    ))
#+END_SRC

* Company
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.
[[http://company-mode.github.io/][official page]]

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config (add-hook 'after-init-hook 'global-company-mode)
    ;; (add-to-list 'company-backends 'company-ob-ipython)
    )
#+END_SRC

#+RESULTS:
: t

* Auctex
 #+BEGIN_SRC emacs-lisp

   (use-package tex
     :ensure auctex
     :hook turn-on-flyspell)

   ;;View LaTex compiled pdf in emacs
   (setq TeX-view-program-list '(("Emacs" "emacsclient %o")))
   (setq TeX-view-program-selection '((output-pdf "Emacs")))

   ;;correlate SyncTeX
   ;; (server-start)
   ;; (add-hook 'LaTeX-mode-hook 'TeX-PDF-mode)
   ;; (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
   ;; (setq TeX-source-correlate-method 'synctex)
   ;; (setq TeX-source-correlate-start-server t)

   ;;latexMk
   ;;(require 'auctex-latexmk)
   ;;(auctex-latexmk-setup) 

   ;;CDLaTeX
   ;;(add-hook 'LaTeX-mode-hook 'turn-on-cdlatex) ;with AUCTeX LaTeX mode


   ;;reftex
   ;; Turn on RefTeX in AUCTeX
   ;;(add-hook 'LaTeX-mode-hook 'turn-on-reftex)
   ;; Activate nice interface between RefTeX and AUCTeX
   ;;(setq reftex-plug-into-AUCTeX t)
 #+END_SRC

* Pdf Tools
:PROPERTIES:
:header-args: :tangle no
:END:

#+BEGIN_SRC emacs-lisp :results silent

  ;; (use-package pdf-tools
  ;;   :ensure t
  ;;   :pin manual ;; manually update
  ;;   :config
  ;;   ;; initialise
  ;;   (pdf-tools-install)
  ;;   ;; open pdfs scaled to fit page
  ;;   (setq-default pdf-view-display-size 'fit-page)
  ;;    ;; use normal isearch
  ;;   (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
  ;;   ;; more fine-grained zooming
  ;;   (setq pdf-view-resize-factor 1.1)

  ;;   ;; keyboard shortcuts
  ;;   (define-key pdf-view-mode-map (kbd "h") 'pdf-annot-add-highlight-markup-annotation)
  ;;   (define-key pdf-view-mode-map (kbd "t") 'pdf-annot-add-text-annotation)
  ;;   (define-key pdf-view-mode-map (kbd "D") 'pdf-annot-delete))


  ;; (use-package org-pdfview
  ;;   :ensure t)

#+END_SRC

** Interleave

#+BEGIN_SRC emacs-lisp :results silent
(use-package interleave
  :ensure t
  :config
  )

#+END_SRC

* Hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :config
  (setq hydra-lv nil))

#+END_SRC

A zooming hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-zoom ()
  "zoom"
  ("+" text-scale-increase "in")
  ("=" text-scale-increase "in")
  ("-" text-scale-decrease "out")
  ("_" text-scale-decrease "out")
  ("0" (text-scale-adjust 0) "reset")
  ("q" nil "quit" :color blue))

(bind-keys ("C-x C-0" . hydra-zoom/body)
           ("C-x C-=" . hydra-zoom/body)
           ("C-x C--" . hydra-zoom/body)
           ("C-x C-+" . hydra-zoom/body))

#+END_SRC

* Org mode
Org-mode, as it says on the [[http://orgmode.org/][official web page]] is for keeping notes, maintaining
ToDo lists, doing project planning, and authoring with a fast and effective
plain-text system. You can find a quick tutorial [[http://orgmode.org/worg/org-tutorials/org4beginners.html][here]].

There is an extensive config file from [[http://doc.norang.ca/org-mode.html][Bernt Hansen]] that I hope to continue
implementing.

The settings related to org mode are changing quickly, as I am really
interested in tweaking those, so I decided to move it to a separate file.

#+BEGIN_SRC emacs-lisp
(require 'init-org-mode)
#+END_SRC
 
* Yasnippet

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :diminish yas-minor-mode
  :init (yas-global-mode)
  )
#+END_SRC

* Flycheck

#+BEGIN_SRC emacs-lisp :results silent
;; flycheck
(use-package flycheck
  :ensure t
  :diminish flycheck-mode
  :init (global-flycheck-mode))

#+END_SRC

* Ledger-mode

#+BEGIN_SRC emacs-lisp :results silent
(use-package ledger-mode
  :ensure t
  :mode "\\.ledger\\'"
  :config
  (define-key ledger-mode-map (kbd "C-c c") 'ledger-mode-clean-buffer)
  (setq ledger-post-amount-alignment-at :decimal
        ledger-post-amount-alignment-column 49
        ledger-clear-whole-transactions t)
  (use-package flycheck-ledger
    :ensure t ))

#+END_SRC

* Git
Adding a new section about all git-related stuff

** Magit
Magit is an interface to the version control system Git, implemented as an
Emacs package.

#+BEGIN_SRC emacs-lisp :results silent
(use-package magit
  :ensure t
  :init
  (progn
  (bind-key "C-x g" 'magit-status)
  )
  :config
  (setq vc-handled-backends (delq 'Git vc-handled-backends))
  (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
  global-magit-file-mode
)
#+END_SRC

* Projectile

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :diminish projectile-mode
  :config
  (progn
    (setq projectile-completion-system 'default)
    (setq projectile-enable-caching t)
    (setq projectile-indexing-method 'alien)
    (add-to-list 'projectile-globally-ignored-files "node-modules"))
  :config
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  (projectile-global-mode)
  (projectile-mode +1))
#+END_SRC

* Counsel-projectile

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :ensure t
  :config
  (counsel-projectile-mode)
  )
#+END_SRC

* Ag 

#+BEGIN_SRC emacs-lisp
(use-package ag
  :ensure t
  )
#+END_SRC

* which-key

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :defer 10
  :config
  (progn
    (setq which-key-popup-type 'side-window) ;Default
    ;; (setq which-key-popup-type 'minibuffer)

    (setq which-key-compute-remaps t) ;Show correct descriptions for remapped keys

    (setq which-key-allow-multiple-replacements t) ;Default = nil

    (which-key-mode 1)))

#+END_SRC

* Programming languages
** TODO Emacs Lisp
Check how the function ~check-parens~ and how to make it work with tangle.

#+BEGIN_SRC emacs-lisp
;; (use-package lisp
;;   :ensure nil
;;   :hook
;;   (after-save . check-parens))
#+END_SRC

** Python
Some configurations for elpy mode taken from [[https://github.com/jorgenschaefer/elpy/wiki/Configuration][here]]
Also from [[https://github.com/zamansky/using-emacs/blob/master/myinit.org][CestlaZ]]

Useful to solve conflict between elpy and ob-ipython
[[https://necromuralist.github.io/posts/org-babel-ipython-and-elpy-conflict/][link]]

#+BEGIN_SRC emacs-lisp :results silent

;; (setq py-python-command "python3")
;; (setq python-shell-interpreter "python3")
;; (setq elpy-rpc-backend "jedi")

;; (use-package jedi
;;   :ensure t
;;   :init
;;   (add-hook 'python-mode-hook 'jedi:setup)
;;   (add-hook 'python-mode-hook 'jedi:ac-setup))

(use-package elpy
  :ensure t
  :config 
  (elpy-enable)
  (setq python-shell-interpreter "ipython"
        python-shell-interpreter-args "-i --simple-prompt"))

(use-package virtualenvwrapper
  :ensure t
  :config
  (venv-initialize-interactive-shells)
  (venv-initialize-eshell))


#+END_SRC

*** Ein
The Emacs IPython Notebook

#+BEGIN_SRC emacs-lisp
(use-package ein
  :ensure t
  :commands (ein:notebooklist-open))

#+END_SRC

*** Virtualenv

#+BEGIN_SRC emacs-lisp :results silent
(setenv "WORKON_HOME" "/home/carlosperez/anaconda3/envs")
(pyvenv-mode 1)
#+END_SRC

** Bash
Use company mode with bash
#+BEGIN_SRC emacs-lisp :results silent
(add-hook 'shell-mode-hook #'company-mode)
(define-key shell-mode-map (kbd "TAB") #'company-manual-begin)

#+END_SRC

** CPP

#+BEGIN_SRC emacs-lisp
(use-package irony
  :ensure t
  :config (add-hook 'c++-mode-hook 'irony-mode)
  (add-hook 'c-mode-hook 'irony-mode)
  (add-hook 'objc-mode-hook 'irony-mode)

  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))


(use-package company-c-headers
  :ensure t
  :config
  (add-to-list 'company-backends 'company-c-headers)
  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode)))


;; (require 'company-irony-c-headers)
;; Load with `irony-mode` as a grouped backend
;; (eval-after-load 'company
;;   '(add-to-list
;;     'company-backends '(company-irony-c-headers company-irony)))

(use-package clang-format
  :ensure t
  :config
  (global-set-key (kbd "C-c i") 'clang-format-region)
  (global-set-key (kbd "C-c u") 'clang-format-buffer)

  (setq clang-format-style-option "llvm"))

#+END_SRC

** Geiser

#+BEGIN_SRC emacs-lisp
(use-package geiser
  :ensure t)
#+END_SRC

** Dumb-jump

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :bind (("M-g o" . dumb-jump-go-other-window)
         ("M-g j" . dumb-jump-go)
         ("M-g i" . dumb-jump-go-prompt)
         ("M-g x" . dumb-jump-go-prefer-external)
         ("M-g z" . dumb-jump-go-prefer-external-other-window))
  :config (setq dumb-jump-selector 'ivy) ;; (setq dumb-jump-selector 'helm)
  :ensure t)
#+END_SRC

* Hugo blog
** Basic setup
#+BEGIN_SRC emacs-lisp
(use-package ox-hugo
  :ensure t            ;Auto-install the package from Melpa (optional)
  :after ox
)
#+END_SRC

Last modified function taken from here: 
#+BEGIN_SRC emacs-lisp
(defun my/ox-hugo-add-lastmod ()
  "Add `lastmod' property with the current time."
  (interactive) 
  (org-set-property "EXPORT_HUGO_LASTMOD"
                    (format-time-string "[%Y-%m-%d %a %H:%M]")))
#+END_SRC

** emacs-easy-hugo
:PROPERTIES:
:header-args:emacs-lisp:     :tangle no
:END:

#+BEGIN_SRC emacs-lisp
(use-package easy-hugo
  :ensure t
  :init
  (setq easy-hugo-basedir "~/Documents/blog-hugo")
  (setq easy-hugo-postdir "content/post")
  (setq easy-hugo-previewtime "300")
  (setq easy-hugo-url "")
  (setq easy-hugo-preview-url "http://localhost:1313/blog/")
  (setq easy-hugo-sshdomain "")
  (setq easy-hugo-root "")
  (setq easy-hugo-default-ext ".md")
  ;;:bind ("C-c C-e" . easy-hugo)
)

#+END_SRC

** Capture setup

* CV
:PROPERTIES:
:header-args:emacs-lisp:     :tangle no
:END:

My CV configuration
#+BEGIN_SRC emacs-lisp :results silent
(use-package ox-moderncv
  :load-path "/home/carlosperez/Documents/CV/org-cv/"
  :init (require 'ox-moderncv))
#+END_SRC

This package allows to have a single org file and different export options.

* Auto-insert
   #+BEGIN_SRC emacs-lisp
     (use-package autoinsert
       :init
       ;; Don't want to be prompted before insertion:
       (setq auto-insert-query nil)

       (add-hook 'find-file-hook 'auto-insert)
       (auto-insert-mode 1))
   #+END_SRC

* Final configuration
Before we finish, we need to check if there is a local file for us to load
and evaluate.  We assume the local file has been tangled and provides the
=init-local= key:

#+BEGIN_SRC emacs-lisp
(require 'init-local nil t)
#+END_SRC

After the first load, we can reload this with a require:

   #+BEGIN_SRC emacs-lisp
(provide 'init-main)
   #+END_SRC

Before you can build this on a new system, make sure that you put the cursor
over any of these properties, and hit: =C-c C-c=

Finally, show elapsed time

#+BEGIN_SRC emacs-lisp
;; Message how long it took to load everything (minus packages)
(let ((elapsed (float-time (time-subtract (current-time)
                                          emacs-start-time))))
  (message "Loading settings...done (%.3fs)" elapsed))
#+END_SRC

